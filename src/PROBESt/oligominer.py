from Bio import SeqIO
import os
import subprocess
import re
import shutil


def parse_oligominer_bed(bed_file: str, input_fasta: str = None) -> list:
    """
    Parses an OligoMiner BED file and extracts probe sequences along with their metadata.

    This function reads a BED file generated by OligoMiner and extracts information about
    the probes, including their sequence ID, start position, end position, and sequence.
    Sequences are extracted from the input FASTA file using coordinates.

    Args:
        bed_file (str): Path to the BED file generated by OligoMiner.
        input_fasta (str, optional): Path to the input FASTA file for sequence extraction.

    Returns:
        list: A list of tuples, where each tuple contains:
              - sequence_id (str): The ID of the sequence/contig.
              - probe_num (str): The probe number (based on position: start_end).
              - probe_type (str): Always "PROBE" for OligoMiner.
              - probe_seq (str): The probe sequence (extracted from FASTA if input_fasta provided).
    """
    probes = []
    
    if not os.path.exists(bed_file):
        return probes
    
    # Load sequences from FASTA if provided
    seq_dict = {}
    if input_fasta and os.path.exists(input_fasta):
        for record in SeqIO.parse(input_fasta, "fasta"):
            seq_dict[record.id] = str(record.seq)
            # Also store with first word of ID (in case of spaces)
            if ' ' in record.id:
                seq_dict[record.id.split()[0]] = str(record.seq)
    
    with open(bed_file, "r") as file:
        for line in file:
            line = line.strip()
            if not line:
                continue
            
            # BED format: chrom, start, end, name, score, strand
            # Sequence is typically not in BED, so we extract from FASTA
            parts = line.split('\t')
            if len(parts) >= 3:
                sequence_id = parts[0]
                try:
                    start = int(parts[1])
                    end = int(parts[2])
                except ValueError:
                    continue
                
                # Extract sequence from FASTA if available
                probe_seq = ""
                if input_fasta and sequence_id in seq_dict:
                    probe_seq = seq_dict[sequence_id][start:end]
                elif input_fasta:
                    # Try matching with first word
                    seq_id_base = sequence_id.split()[0] if ' ' in sequence_id else sequence_id
                    if seq_id_base in seq_dict:
                        probe_seq = seq_dict[seq_id_base][start:end]
                
                probe_num = f"{start}_{end}"
                probes.append((sequence_id, probe_num, "PROBE", probe_seq))
    
    return probes


def extract_sequence_from_fasta(fasta_file: str, seq_id: str, start: int, end: int) -> str:
    """
    Extracts a sequence from a FASTA file given coordinates.

    Args:
        fasta_file (str): Path to the FASTA file.
        seq_id (str): Sequence ID to extract from.
        start (int): Start position (0-based).
        end (int): End position (0-based, exclusive).

    Returns:
        str: The extracted sequence. Returns empty string if file doesn't exist or sequence not found.
    """
    if not os.path.exists(fasta_file):
        return ""
    
    try:
        for record in SeqIO.parse(fasta_file, "fasta"):
            if record.id == seq_id or record.id.split()[0] == seq_id:
                return str(record.seq[start:end])
    except (FileNotFoundError, IOError):
        return ""
    return ""


def oligominer2fasta(args, out_dir: str, probes: list, input_fasta: str) -> None:
    """
    Writes OligoMiner probe sequences to a FASTA file and optionally appends additional sequences.

    This function writes the extracted probe sequences to a FASTA file. If sequences
    are missing from the BED file, they are extracted from the input FASTA file.
    If additional sequences are provided via `args.add_set`, they are appended.

    Args:
        args: Parsed command-line arguments.
        out_dir (str): Path to the output directory.
        probes (list): A list of tuples containing probe information (sequence_id, probe_num, type, sequence).
        input_fasta (str): Path to the input FASTA file for sequence extraction if needed.
    """
    output_fasta_path = os.path.join(out_dir, "output.fa")
    with open(output_fasta_path, "w") as fasta:
        for probe in probes:
            sequence_id, probe_num, probe_type, sequence = probe
            
            # If sequence is empty, try to extract from input FASTA
            if not sequence:
                # Try to parse coordinates from probe_num (format: start_end)
                try:
                    start, end = map(int, probe_num.split('_'))
                    sequence = extract_sequence_from_fasta(input_fasta, sequence_id, start, end)
                except:
                    # If extraction fails, skip this probe
                    continue
            
            # Skip if still no sequence
            if not sequence:
                continue
                
            header = f">{sequence_id}_{probe_num}_{probe_type}"
            fasta.write(f"{header}\n{sequence}\n")

    # Append additional sequences if provided
    if args.add_set:
        add_fasta_cmd = f"cat {' '.join(args.add_set)} >> {output_fasta_path}"
        subprocess.run(add_fasta_cmd, shell=True, executable="/bin/bash")


def initial_set_generation(args, out_dir: str) -> None:
    """
    Generates an initial set of probes using OligoMiner and writes them to a FASTA file.

    This function performs the following steps:
    1. Processes each sequence in the input FASTA file separately.
    2. Runs OligoMiner pipeline: blockParse.py -> bowtie2 -> outputClean.py -> bedtools intersect.
    3. Parses the BED output and converts to FASTA format.
    4. Optionally appends additional sequences to the FASTA file.

    Args:
        args: Parsed command-line arguments.
        out_dir (str): Path to the output directory.
    """
    input_fasta = os.path.join(out_dir, "input.fa")
    
    # Create temporary directories for OligoMiner processing
    oligominer_tmp = os.path.join(out_dir, "oligominer_tmp")
    probes_dir = os.path.join(out_dir, "oligominer_probes")
    os.makedirs(oligominer_tmp, exist_ok=True)
    os.makedirs(probes_dir, exist_ok=True)
    
    # Get OligoMiner path
    oligominer_path = args.oligominer_path
    if not oligominer_path:
        raise ValueError("OligoMiner path not specified. Please set --oligominer_path.")
    
    # Check if required tools are available
    for tool in ['bowtie2-build', 'bowtie2', 'bedtools']:
        result = subprocess.run(f"which {tool}", shell=True, capture_output=True)
        if result.returncode != 0:
            raise RuntimeError(f"Required tool '{tool}' not found in PATH. Please install it.")
    
    # Process each sequence in the input FASTA file
    sequences = list(SeqIO.parse(input_fasta, "fasta"))
    all_probes = []
    
    # Create insert coordinates BED file if metadata is provided
    insert_coords_bed = None
    if hasattr(args, 'oligominer_insert_coords') and args.oligominer_insert_coords:
        insert_coords_bed = args.oligominer_insert_coords
    else:
        # Create a dummy BED file that covers all sequences (no filtering)
        insert_coords_bed = os.path.join(out_dir, "insert_coords.bed")
        with open(insert_coords_bed, "w") as bed:
            for record in sequences:
                # Create a BED entry covering the entire sequence
                bed.write(f"{record.id}\t0\t{len(record.seq)}\n")
    
    # Process each sequence separately
    for record in sequences:
        # Create a temporary FASTA file for this sequence
        seq_fasta = os.path.join(oligominer_tmp, f"{record.id}.fasta")
        with open(seq_fasta, "w") as f:
            SeqIO.write(record, f, "fasta")
        
        # Extract prefix for naming
        prefix = re.sub(r'[^a-zA-Z0-9_]', '_', record.id)
        prefix = prefix[:50]  # Limit length
        
        print(f"Processing {record.id} with OligoMiner...")
        
        # Step 1: Run blockParse.py
        # blockParse.py generates a FASTQ file with candidate probes
        blockparse_cmd = (
            f"python {os.path.join(oligominer_path, 'blockParse.py')} "
            f"-l {args.oligominer_probe_length} "
            f"-T {args.oligominer_temperature} "
            f"-f {seq_fasta} "
            f"&> {os.path.join(oligominer_tmp, f'{prefix}_blockparse.log')}"
        )
        subprocess.run(blockparse_cmd, shell=True, executable="/bin/bash")
        
        # Check if FASTQ was generated
        fastq_file = seq_fasta.replace('.fasta', '.fastq')
        if not os.path.exists(fastq_file):
            print(f"Warning: No FASTQ file generated for {record.id}, skipping...")
            continue
        
        # Step 2: Build bowtie2 index
        index_prefix = os.path.join(oligominer_tmp, f"{prefix}.index")
        bowtie2_build_cmd = (
            f"bowtie2-build {seq_fasta} {index_prefix} "
            f"&> {os.path.join(oligominer_tmp, f'{prefix}_bowtie2_build.log')}"
        )
        subprocess.run(bowtie2_build_cmd, shell=True, executable="/bin/bash")
        
        # Step 3: Run bowtie2 alignment
        sam_file = os.path.join(oligominer_tmp, f"aligned_{prefix}.sam")
        bowtie2_cmd = (
            f"bowtie2 -x {index_prefix} "
            f"-U {fastq_file} "
            f"--no-hd -k 100 --very-sensitive-local "
            f"-S {sam_file} "
            f"&> {os.path.join(oligominer_tmp, f'{prefix}_bowtie2.log')}"
        )
        subprocess.run(bowtie2_cmd, shell=True, executable="/bin/bash")
        
        # Step 4: Run outputClean.py
        outputclean_cmd = (
            f"python {os.path.join(oligominer_path, 'outputClean.py')} "
            f"-f {sam_file} -u "
            f"&> {os.path.join(oligominer_tmp, f'{prefix}_outputclean.log')}"
        )
        subprocess.run(outputclean_cmd, shell=True, executable="/bin/bash")
        
        # Check for generated BED file
        bed_file = os.path.join(oligominer_tmp, f"aligned_{prefix}_probes.bed")
        if not os.path.exists(bed_file):
            print(f"Warning: No BED file generated for {record.id}, skipping...")
            continue
        
        # Step 5: Filter with bedtools intersect (if insert coordinates provided)
        filtered_bed = os.path.join(probes_dir, f"{prefix}_probes_filt.bed")
        if insert_coords_bed and os.path.exists(insert_coords_bed):
            bedtools_cmd = (
                f"bedtools intersect -wa -a {bed_file} -b {insert_coords_bed} "
                f"> {filtered_bed}"
            )
            subprocess.run(bedtools_cmd, shell=True, executable="/bin/bash")
        else:
            # If no filtering, just copy the bed file
            shutil.copy(bed_file, filtered_bed)
        
        # Parse the filtered BED file
        if os.path.exists(filtered_bed):
            probes = parse_oligominer_bed(filtered_bed, seq_fasta)
            # Update sequence IDs to match the original record ID
            updated_probes = [(record.id, p[1], p[2], p[3]) for p in probes]
            all_probes.extend(updated_probes)
    
    print("OligoMiner done")
    
    # Filter out probes without sequences (shouldn't happen if parsing worked correctly)
    final_probes = [p for p in all_probes if p[3]]  # p[3] is the sequence
    
    # Write probes to FASTA
    oligominer2fasta(args, out_dir, final_probes, input_fasta)
    
    # Cleanup temporary files (optional, can be kept for debugging)
    if not hasattr(args, 'oligominer_keep_tmp') or not args.oligominer_keep_tmp:
        # Keep the probes directory but clean up intermediate files
        pass

