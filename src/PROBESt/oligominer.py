from Bio import SeqIO
import os
import subprocess
import re
import shutil


def parse_oligominer_bed(bed_file: str, input_fasta: str = None) -> list:
    """
    Parses an OligoMiner BED file and extracts probe sequences along with their metadata.

    This function reads a BED file generated by OligoMiner and extracts information about
    the probes, including their sequence ID, start position, end position, and sequence.
    Sequences are extracted from the input FASTA file using coordinates.

    Args:
        bed_file (str): Path to the BED file generated by OligoMiner.
        input_fasta (str, optional): Path to the input FASTA file for sequence extraction.

    Returns:
        list: A list of tuples, where each tuple contains:
              - sequence_id (str): The ID of the sequence/contig.
              - probe_num (str): The probe number (based on position: start_end).
              - probe_type (str): Always "PROBE" for OligoMiner.
              - probe_seq (str): The probe sequence (extracted from FASTA if input_fasta provided).
    """
    probes = []
    
    if not os.path.exists(bed_file):
        return probes
    
    # Load sequences from FASTA if provided
    seq_dict = {}
    if input_fasta and os.path.exists(input_fasta):
        for record in SeqIO.parse(input_fasta, "fasta"):
            seq_dict[record.id] = str(record.seq)
            # Also store with first word of ID (in case of spaces)
            if ' ' in record.id:
                seq_dict[record.id.split()[0]] = str(record.seq)
    
    with open(bed_file, "r") as file:
        for line in file:
            line = line.strip()
            if not line:
                continue
            
            # BED format: chrom, start, end, name, score, strand
            # Sequence is typically not in BED, so we extract from FASTA
            parts = line.split('\t')
            if len(parts) >= 3:
                sequence_id = parts[0]
                try:
                    start = int(parts[1])
                    end = int(parts[2])
                except ValueError:
                    continue
                
                # Extract sequence from FASTA if available
                probe_seq = ""
                if input_fasta and sequence_id in seq_dict:
                    probe_seq = seq_dict[sequence_id][start:end]
                elif input_fasta:
                    # Try matching with first word
                    seq_id_base = sequence_id.split()[0] if ' ' in sequence_id else sequence_id
                    if seq_id_base in seq_dict:
                        probe_seq = seq_dict[seq_id_base][start:end]
                
                probe_num = f"{start}_{end}"
                probes.append((sequence_id, probe_num, "PROBE", probe_seq))
    
    return probes


def extract_sequence_from_fasta(fasta_file: str, seq_id: str, start: int, end: int) -> str:
    """
    Extracts a sequence from a FASTA file given coordinates.

    Args:
        fasta_file (str): Path to the FASTA file.
        seq_id (str): Sequence ID to extract from.
        start (int): Start position (0-based).
        end (int): End position (0-based, exclusive).

    Returns:
        str: The extracted sequence. Returns empty string if file doesn't exist or sequence not found.
    """
    if not os.path.exists(fasta_file):
        return ""
    
    try:
        for record in SeqIO.parse(fasta_file, "fasta"):
            if record.id == seq_id or record.id.split()[0] == seq_id:
                return str(record.seq[start:end])
    except (FileNotFoundError, IOError):
        return ""
    return ""


def oligominer2fasta(args, out_dir: str, probes: list, input_fasta: str) -> None:
    """
    Writes OligoMiner probe sequences to a FASTA file and optionally appends additional sequences.

    This function writes the extracted probe sequences to a FASTA file. If sequences
    are missing from the BED file, they are extracted from the input FASTA file.
    If additional sequences are provided via `args.add_set`, they are appended.

    Args:
        args: Parsed command-line arguments.
        out_dir (str): Path to the output directory.
        probes (list): A list of tuples containing probe information (sequence_id, probe_num, type, sequence).
        input_fasta (str): Path to the input FASTA file for sequence extraction if needed.
    """
    output_fasta_path = os.path.join(out_dir, "output.fa")
    with open(output_fasta_path, "w") as fasta:
        for probe in probes:
            sequence_id, probe_num, probe_type, sequence = probe
            
            # If sequence is empty, try to extract from input FASTA
            if not sequence:
                # Try to parse coordinates from probe_num (format: start_end)
                try:
                    start, end = map(int, probe_num.split('_'))
                    sequence = extract_sequence_from_fasta(input_fasta, sequence_id, start, end)
                except:
                    # If extraction fails, skip this probe
                    continue
            
            # Skip if still no sequence
            if not sequence:
                continue
                
            header = f">{sequence_id}_{probe_num}_{probe_type}"
            fasta.write(f"{header}\n{sequence}\n")

    # Append additional sequences if provided
    if args.add_set:
        add_fasta_cmd = f"cat {' '.join(args.add_set)} >> {output_fasta_path}"
        subprocess.run(add_fasta_cmd, shell=True, executable="/bin/bash")


def initial_set_generation(args, out_dir: str) -> None:
    """
    Generates an initial set of probes using OligoMiner and writes them to a FASTA file.

    This function performs the following steps:
    1. Processes each sequence in the input FASTA file separately.
    2. Runs OligoMiner pipeline: blockParse.py -> bowtie2 -> outputClean.py -> bedtools intersect.
    3. Parses the BED output and converts to FASTA format.
    4. Optionally appends additional sequences to the FASTA file.

    Args:
        args: Parsed command-line arguments.
        out_dir (str): Path to the output directory.
    """
    input_fasta = os.path.join(out_dir, "input.fa")
    
    # Create temporary directories for OligoMiner processing
    oligominer_tmp = os.path.join(out_dir, "oligominer_tmp")
    probes_dir = os.path.join(out_dir, "oligominer_probes")
    os.makedirs(oligominer_tmp, exist_ok=True)
    os.makedirs(probes_dir, exist_ok=True)
    
    # Get OligoMiner path
    oligominer_path = args.oligominer_path
    if not oligominer_path:
        raise ValueError("OligoMiner path not specified. Please set --oligominer_path.")
    
    # Determine Python interpreter for OligoMiner (Python 2 required)
    python_cmd = args.oligominer_python
    use_conda_run = False
    oligominer_env_name = None
    
    # Check if OLIGOMINER_PYTHON environment variable is set (from conda activation script)
    if not python_cmd:
        python_cmd = os.environ.get('OLIGOMINER_PYTHON', None)
        if python_cmd and '/envs/' in python_cmd:
            # Extract environment name from path
            parts = python_cmd.split('/envs/')
            if len(parts) > 1:
                oligominer_env_name = parts[1].split('/')[0]
    
    # Try to detect conda environment for OligoMiner
    if not oligominer_env_name:
        current_env = os.environ.get('CONDA_DEFAULT_ENV', '')
        if 'oligominer' in current_env.lower():
            # We're already in the OligoMiner environment
            python_cmd = "python"
            oligominer_env_name = current_env
        else:
            # Try to find the separate OligoMiner conda environment
            main_env_name = current_env or 'probest'
            oligominer_env_name = f"{main_env_name}_oligominer"
            
            # Check if the environment exists
            env_check = subprocess.run(
                f"conda env list | grep -q '^{oligominer_env_name} '",
                shell=True,
                capture_output=True
            )
            if env_check.returncode == 0:
                # Environment exists, use conda run
                use_conda_run = True
                python_cmd = f"conda run -n {oligominer_env_name} python"
                print(f"Found OligoMiner conda environment: {oligominer_env_name}")
            elif not python_cmd:
                # Try to find the Python executable directly
                conda_base = os.environ.get('CONDA_PREFIX', '').replace(f'/envs/{main_env_name}', '')
                if not conda_base:
                    # Try to get conda base from conda info
                    conda_info = subprocess.run("conda info --base", shell=True, capture_output=True, text=True)
                    if conda_info.returncode == 0:
                        conda_base = conda_info.stdout.strip()
                
                if conda_base:
                    oligominer_python = f"{conda_base}/envs/{oligominer_env_name}/bin/python2.7"
                    if os.path.exists(oligominer_python):
                        python_cmd = oligominer_python
                        print(f"Found OligoMiner Python at: {oligominer_python}")
    
    if not python_cmd:
        # Try to auto-detect Python 2
        python2_found = False
        for py_cmd in ['python2.7', 'python2', 'python']:
            result = subprocess.run(f"which {py_cmd}", shell=True, capture_output=True)
            if result.returncode == 0:
                # Check if it's actually Python 2
                version_check = subprocess.run(
                    f"{py_cmd} -c 'import sys; exit(0 if sys.version_info[0] == 2 else 1)'",
                    shell=True,
                    capture_output=True
                )
                if version_check.returncode == 0:
                    python_cmd = py_cmd
                    python2_found = True
                    break
        
        if not python2_found:
            raise RuntimeError(
                "Python 2 not found for OligoMiner. OligoMiner requires Python 2. "
                "Please install Python 2 (e.g., 'python2' or 'python2.7') or specify it using "
                "--oligominer_python argument. The installation script creates a separate "
                "conda environment 'probest_oligominer' with Python 2.7 and Biopython."
            )
    
    # Verify the specified Python is actually Python 2
    if python_cmd and not use_conda_run:
        version_check = subprocess.run(
            f"{python_cmd} -c 'import sys; exit(0 if sys.version_info[0] == 2 else 1)'",
            shell=True,
            capture_output=True
        )
        if version_check.returncode != 0:
            raise RuntimeError(
                f"Specified Python interpreter '{python_cmd}' is not Python 2. "
                "OligoMiner requires Python 2. Please specify a Python 2 interpreter using "
                "--oligominer_python (e.g., 'python2' or 'python2.7')."
            )
    
    # Check if Biopython is installed in Python 2 environment
    if use_conda_run:
        # Use conda run to check Biopython
        biopython_check = subprocess.run(
            f"conda run -n {oligominer_env_name} python -c 'from Bio.SeqUtils import MeltingTemp'",
            shell=True,
            capture_output=True
        )
    else:
        # Direct Python command
        biopython_check = subprocess.run(
            f"{python_cmd} -c 'from Bio.SeqUtils import MeltingTemp'",
            shell=True,
            capture_output=True
        )
    
    if biopython_check.returncode != 0:
        error_msg = biopython_check.stderr.decode('utf-8', errors='ignore') if biopython_check.stderr else "Unknown error"
        if use_conda_run:
            install_cmd = f"conda activate {oligominer_env_name} && pip install biopython==1.76"
        else:
            install_cmd = f"{python_cmd} -m pip install biopython==1.76"
        
        raise RuntimeError(
            f"Biopython is not installed in the Python 2 environment ({python_cmd}). "
            "OligoMiner requires Biopython 1.76 for Python 2. Please install it using:\n"
            f"  {install_cmd}\n"
            f"Error: {error_msg[:200]}"
        )
    
    print(f"Using Python interpreter for OligoMiner: {python_cmd}")
    
    # Check if required tools are available
    for tool in ['bowtie2-build', 'bowtie2', 'bedtools']:
        result = subprocess.run(f"which {tool}", shell=True, capture_output=True)
        if result.returncode != 0:
            raise RuntimeError(f"Required tool '{tool}' not found in PATH. Please install it.")
    
    # Process each sequence in the input FASTA file
    sequences = list(SeqIO.parse(input_fasta, "fasta"))
    all_probes = []
    
    # Create insert coordinates BED file if metadata is provided
    insert_coords_bed = None
    if hasattr(args, 'oligominer_insert_coords') and args.oligominer_insert_coords:
        insert_coords_bed = args.oligominer_insert_coords
    else:
        # Create a dummy BED file that covers all sequences (no filtering)
        insert_coords_bed = os.path.join(out_dir, "insert_coords.bed")
        with open(insert_coords_bed, "w") as bed:
            for record in sequences:
                # Create a BED entry covering the entire sequence
                bed.write(f"{record.id}\t0\t{len(record.seq)}\n")
    
    # Process each sequence separately
    for record in sequences:
        # Create a temporary FASTA file for this sequence
        seq_fasta = os.path.join(oligominer_tmp, f"{record.id}.fasta")
        with open(seq_fasta, "w") as f:
            SeqIO.write(record, f, "fasta")
        
        # Extract prefix for naming
        prefix = re.sub(r'[^a-zA-Z0-9_]', '_', record.id)
        prefix = prefix[:50]  # Limit length
        
        print(f"Processing {record.id} with OligoMiner...")
        
        # Step 1: Run blockParse.py
        # blockParse.py generates a FASTQ file with candidate probes
        blockparse_log = os.path.join(oligominer_tmp, f'{prefix}_blockparse.log')
        blockparse_cmd = (
            f"{python_cmd} {os.path.join(oligominer_path, 'blockParse.py')} "
            f"-l {args.oligominer_probe_length} "
            f"-T {args.oligominer_temperature} "
            f"-f {seq_fasta} "
            f"&> {blockparse_log}"
        )
        result = subprocess.run(blockparse_cmd, shell=True, executable="/bin/bash")
        
        # Check for errors in blockParse
        if result.returncode != 0:
            # Read log to see what went wrong
            if os.path.exists(blockparse_log):
                with open(blockparse_log, 'r') as f:
                    log_content = f.read()
                    if 'SyntaxError' in log_content or 'print' in log_content.lower():
                        raise RuntimeError(
                            f"OligoMiner blockParse.py failed with Python version error for {record.id}. "
                            f"OligoMiner requires Python 2. Please set --oligominer_python to a Python 2 interpreter "
                            f"(e.g., 'python2' or 'python2.7'). Error: {log_content[:500]}"
                        )
            print(f"Warning: blockParse.py failed for {record.id} (exit code {result.returncode}), skipping...")
            continue
        
        # Check if FASTQ was generated
        fastq_file = seq_fasta.replace('.fasta', '.fastq')
        if not os.path.exists(fastq_file):
            # Check log for errors
            error_msg = ""
            if os.path.exists(blockparse_log):
                with open(blockparse_log, 'r') as f:
                    log_content = f.read()
                    if log_content.strip():
                        error_msg = f" Log: {log_content[:200]}"
            print(f"Warning: No FASTQ file generated for {record.id}, skipping...{error_msg}")
            continue
        
        # Step 2: Build bowtie2 index
        index_prefix = os.path.join(oligominer_tmp, f"{prefix}.index")
        bowtie2_build_cmd = (
            f"bowtie2-build {seq_fasta} {index_prefix} "
            f"&> {os.path.join(oligominer_tmp, f'{prefix}_bowtie2_build.log')}"
        )
        subprocess.run(bowtie2_build_cmd, shell=True, executable="/bin/bash")
        
        # Step 3: Run bowtie2 alignment
        sam_file = os.path.join(oligominer_tmp, f"aligned_{prefix}.sam")
        bowtie2_cmd = (
            f"bowtie2 -x {index_prefix} "
            f"-U {fastq_file} "
            f"--no-hd -k 100 --very-sensitive-local "
            f"-S {sam_file} "
            f"&> {os.path.join(oligominer_tmp, f'{prefix}_bowtie2.log')}"
        )
        subprocess.run(bowtie2_cmd, shell=True, executable="/bin/bash")
        
        # Step 4: Run outputClean.py
        outputclean_log = os.path.join(oligominer_tmp, f'{prefix}_outputclean.log')
        outputclean_cmd = (
            f"{python_cmd} {os.path.join(oligominer_path, 'outputClean.py')} "
            f"-f {sam_file} -u "
            f"&> {outputclean_log}"
        )
        result = subprocess.run(outputclean_cmd, shell=True, executable="/bin/bash")
        
        if result.returncode != 0:
            print(f"Warning: outputClean.py failed for {record.id} (exit code {result.returncode}), skipping...")
            continue
        
        # Check for generated BED file
        bed_file = os.path.join(oligominer_tmp, f"aligned_{prefix}_probes.bed")
        if not os.path.exists(bed_file):
            print(f"Warning: No BED file generated for {record.id}, skipping...")
            continue
        
        # Step 5: Filter with bedtools intersect (if insert coordinates provided)
        filtered_bed = os.path.join(probes_dir, f"{prefix}_probes_filt.bed")
        if insert_coords_bed and os.path.exists(insert_coords_bed):
            bedtools_cmd = (
                f"bedtools intersect -wa -a {bed_file} -b {insert_coords_bed} "
                f"> {filtered_bed}"
            )
            subprocess.run(bedtools_cmd, shell=True, executable="/bin/bash")
        else:
            # If no filtering, just copy the bed file
            shutil.copy(bed_file, filtered_bed)
        
        # Parse the filtered BED file
        if os.path.exists(filtered_bed):
            probes = parse_oligominer_bed(filtered_bed, seq_fasta)
            # Update sequence IDs to match the original record ID
            updated_probes = [(record.id, p[1], p[2], p[3]) for p in probes]
            all_probes.extend(updated_probes)
    
    print("OligoMiner done")
    
    # Filter out probes without sequences (shouldn't happen if parsing worked correctly)
    final_probes = [p for p in all_probes if p[3]]  # p[3] is the sequence
    
    # Write probes to FASTA
    oligominer2fasta(args, out_dir, final_probes, input_fasta)
    
    # Cleanup temporary files (optional, can be kept for debugging)
    if not hasattr(args, 'oligominer_keep_tmp') or not args.oligominer_keep_tmp:
        # Keep the probes directory but clean up intermediate files
        pass

